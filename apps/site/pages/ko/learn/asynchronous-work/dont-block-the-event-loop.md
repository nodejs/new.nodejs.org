---
title: 이벤트 루프(또는 워커 풀)를 차단하지 마세요
layout: learn
---

# 이벤트 루프(또는 워커 풀)를 차단하지 마세요

## 이 가이드를 읽어야 하나요?

간단한 명령줄 스크립트 이상의 복잡한 코드를 작성하고 있다면, 이 문서를 읽으면 더 높은 성능과 더 안전한 애플리케이션을 작성하는 데 도움이 될 것입니다.

이 문서는 Node.js 서버를 염두에 두고 작성되었지만, 복잡한 Node.js 애플리케이션에도 동일한 개념이 적용됩니다. 운영 체제에 따라 다를 수 있는 세부 사항이 있지만, 이 문서는 리눅스를 중심으로 설명합니다.

## 요약

Node.js는 이벤트 루프에서 JavaScript 코드를 실행하고(초기화 및 콜백), 파일 I/O와 같은 비용이 많이 드는 작업을 처리하기 위해 워커 풀을 제공합니다. Node.js는 때로는 Apache와 같은 더 무거운 방식보다 더 잘 확장됩니다. Node.js의 확장성 비결은 소수의 스레드로 많은 클라이언트를 처리한다는 점입니다. Node.js가 더 적은 스레드로 작업할 수 있다면, 시스템의 시간과 메모리를 스레드(메모리, 컨텍스트 스위칭)에 대한 공간과 시간 오버헤드 대신 클라이언트 작업에 더 많이 할애할 수 있습니다. 하지만 Node.js에는 적은 스레드만 있으므로 애플리케이션을 현명하게 구조화해야 합니다.

Node.js 서버를 빠르게 유지하는 좋은 경험 법칙은 다음과 같습니다:
_Node.js는 각 클라이언트와 관련된 작업이 어느 순간 "작을" 때 빠릅니다_.

이 규칙은 이벤트 루프의 콜백과 워커 풀의 작업에 적용됩니다.

## 왜 이벤트 루프와 워커 풀을 차단하지 말아야 하나요?

Node.js는 소수의 스레드로 많은 클라이언트를 처리합니다. Node.js에는 두 가지 유형의 스레드가 있습니다: 하나의 이벤트 루프(메인 루프, 메인 스레드, 이벤트 스레드 등)와 `k` 개의 워커를 포함하는 워커 풀(스레드풀).

콜백(이벤트 루프) 또는 작업(워커)을 실행하는 스레드가 오랜 시간을 소모하면, 우리는 이를 "차단되었다"고 말합니다. 하나의 클라이언트 대신 차단된 스레드가 작업을 수행하는 동안 다른 클라이언트 요청을 처리할 수 없습니다. 이를 피해야 하는 두 가지 이유가 있습니다:

1. 성능: 두 유형의 스레드에서 무거운 작업을 정기적으로 수행하면 서버의 _처리량_(요청/초)이 저하됩니다.
2. 보안: 특정 입력에서 스레드가 차단될 수 있는 경우, 악의적인 클라이언트가 "악성 입력"을 제출하여 스레드를 차단시키고 다른 클라이언트 작업을 방해할 수 있습니다. 이는 [서비스 거부 공격](https://en.wikipedia.org/wiki/Denial-of-service_attack)입니다.

## Node.js의 간단한 개요

Node.js는 이벤트 기반 아키텍처를 사용합니다. 이벤트 루프는 오케스트레이션을 담당하고 워커 풀은 비용이 많이 드는 작업을 처리합니다.

### 이벤트 루프에서 실행되는 코드는 무엇인가요?

Node.js 애플리케이션이 시작될 때, 먼저 초기화 단계를 완료하고, 모듈을 `require`하여 이벤트에 대한 콜백을 등록합니다. 그런 다음, Node.js 애플리케이션은 이벤트 루프로 진입하여 들어오는 클라이언트 요청에 적합한 콜백을 실행합니다. 이 콜백은 동기적으로 실행되며, 완료 후에도 계속 처리하기 위한 비동기 요청을 등록할 수 있습니다. 이러한 비동기 요청의 콜백은 이벤트 루프에서 실행됩니다.

이벤트 루프는 또한 콜백에서 생성된 비차단 비동기 요청(예: 네트워크 I/O)을 처리합니다.

결론적으로, 이벤트 루프는 이벤트에 등록된 JavaScript 콜백을 실행하며, 비차단 비동기 요청(예: 네트워크 I/O)을 처리하는 책임이 있습니다.

### 워커 풀에서 실행되는 코드는 무엇인가요?

Node.js의 워커 풀은 libuv에서 구현되었으며([문서](http://docs.libuv.org/en/v1.x/threadpool.html)), 일반적인 작업 제출 API를 노출합니다.

Node.js는 워커 풀을 사용하여 "비용이 많이 드는" 작업을 처리합니다. 여기에는 운영 체제가 비차단 버전을 제공하지 않는 I/O와 특히 CPU 집약적인 작업이 포함됩니다.

다음 Node.js 모듈 API는 이 워커 풀을 사용합니다:

1. I/O 집약적 작업
   1. [DNS](https://nodejs.org/api/dns.html): `dns.lookup()`, `dns.lookupService()`.
   2. [파일 시스템](https://nodejs.org/api/fs.html#fs_threadpool_usage): `fs.FSWatcher()` 및 명시적으로 동기적인 것을 제외한 모든 파일 시스템 API는 libuv의 스레드풀을 사용합니다.
2. CPU 집약적 작업
   1. [Crypto](https://nodejs.org/api/crypto.html): `crypto.pbkdf2()`, `crypto.scrypt()`, `crypto.randomBytes()`, `crypto.randomFill()`, `crypto.generateKeyPair()`.
   2. [Zlib](https://nodejs.org/api/zlib.html#zlib_threadpool_usage): 명시적으로 동기적인 것을 제외한 모든 zlib API는 libuv의 스레드풀을 사용합니다.

많은 Node.js 애플리케이션에서 이러한 API는 워커 풀 작업의 유일한 소스입니다. [C++ 애드온](https://nodejs.org/api/addons.html)을 사용하는 애플리케이션 및 모듈은 워커 풀에 다른 작업을 제출할 수 있습니다.

완전성을 위해, 이러한 API 중 하나를 이벤트 루프에서 콜백으로 호출할 때, 이벤트 루프는 해당 API에 대한 Node.js C++ 바인딩에 진입하고 워커 풀에 작업을 제출할 때 약간의 설정 비용을 지불한다는 점을 언급합니다. 이러한 비용은 작업의 전체 비용에 비해 미미하므로 이벤트 루프가 이를 오프로드하는 이유입니다. 워커 풀에 이러한 작업을 제출할 때 Node.js는 Node.js C++ 바인딩에서 해당 C++ 함수에 대한 포인터를 제공합니다.

### Node.js는 어떤 코드를 실행할지 어떻게 결정하나요?

추상적으로, 이벤트 루프와 워커 풀은 각각 대기 중인 이벤트와 대기 중인 작업을 위한 큐를 유지합니다.

실제로, 이벤트 루프는 실제로 큐를 유지하지 않습니다. 대신, 운영 체제에 파일 디스크립터를 모니터링하도록 요청합니다. 이를 위해 [epoll](http://man7.org/linux/man-pages/man7/epoll.7.html) (리눅스), [kqueue](https://developer.apple.com/library/content/documentation/Darwin/Conceptual/FSEvents_ProgGuide/KernelQueues/KernelQueues.html) (OSX), 이벤트 포트(솔라리스), 또는 [IOCP](https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx) (윈도우)와 같은 메커니즘을 사용합니다. 이러한 파일 디스크립터는 네트워크 소켓, 감시 중인 파일 등을 나타냅니다. 운영 체제가 이러한 파일 디스크립터 중 하나가 준비되었다고 알리면, 이벤트 루프는 이를 적절한 이벤트로 변환하고 해당 이벤트와 연결된 콜백을 호출합니다. 이 프로세스에 대한 자세한 내용은 [여기](https://www.youtube.com/watch?v=P9csgxBgaZ8)에서 확인할 수 있습니다.

반면, 워커 풀은 처리해야 할 작업을 큐에 실제로 유지합니다. 워커는 이 큐에서 작업을 꺼내서 작업을 수행하며, 완료되면 "최소한 하나의 작업이 완료됨" 이벤트를 이벤트 루프에 전달합니다.

### 이것이 애플리케이션 설계에 무엇을 의미하나요?

Apache와 같은 하나의 스레드를 클라이언트마다 할당하는 시스템에서는 각 대기 중인 클라이언트가 고유의 스레드를 할당받습니다. 하나의 클라이언트를 처리하는 스레드가 차단되면 운영 체제는 이를 중단시키고 다른 클라이언트에 차례를 줍니다. 운영 체제는 작업량이 적은 클라이언트가 작업량이 많은 클라이언트에 의해 피해를 보지 않도록 보장합니다.

Node.js는 소수의 스레드로 많은 클라이언트를 처리하므로, 하나의 스레드가 한 클라이언트의 요청을 처리하는 동안 차단되면 대기 중인 클라이언트 요청은 해당 스레드가 콜백 또는 작업을 완료할 때까지 차례를 얻지 못할 수 있습니다. _클라이언트의 공정한 처리는 귀하의 애플리케이션 책임입니다_. 즉, 단일 콜백 또는 작업에서 너무 많은 작업을 하지 않아야 합니다.

이것이 Node.js가 잘 확장할 수 있는 이유 중 하나지만, 이는 또한 공정한 스케줄링을 보장하는 책임이 귀하에게 있음을 의미합니다. 다음 섹션에서는 이벤트 루프와 워커 풀에서 공정한 스케줄링을 보장하는 방법에 대해 설명합니다.

## 이벤트 루프를 차단하지 마세요

이벤트 루프는 각 클라이언트 연결을 감지하고 응답 생성의 오케스트레이션을 담당합니다. 모든 들어오는 요청과 나가는 응답은 이벤트 루프를 통과합니다. 이는 이벤트 루프가 어느 시점에서 너무 오랜 시간을 소비하면 현재와 새로운 클라이언트가 차례를 얻지 못한다는 것을 의미합니다.

이벤트 루프를 절대 차단하지 않도록 해야 합니다. 즉, 각 JavaScript 콜백이 신속하게 완료되어야 합니다. 물론 이는 `await`와 `Promise.then`에도 적용됩니다.

이를 보장하는 좋은 방법은 콜백의 ["계산 복잡도"](https://en.wikipedia.org/wiki/Time_complexity)에 대해 생각해보는 것입니다. 콜백이 인수와 상관없이 일정한 단계로 실행된다면, 대기 중인 모든 클라이언트에게 공정한 차례를 줄 수 있습니다. 콜백이 인수에 따라 다른 단계 수를 필요로 한다면, 인수가 얼마나 클 수 있는지 고려해야 합니다.

### 예시 1: 상수 시간 콜백.

```js
app.get('/constant-time', (req, res) => {
  res.sendStatus(200);
});
```

예시 2: O(n) 콜백. 이 콜백은 작은 n에서는 신속하게 실행되며, 큰 n에서는 더 느리게 실행됩니다.

```js
app.get('/countToN', (req, res) => {
  let n = req.query.n;

  // n 반복 후 다른 클라이언트에게 차례를 줍니다
  for (let i = 0; i < n; i++) {
    console.log(`Iter ${i}`);
  }

  res.sendStatus(200);
});
```

예시 3: O(n^2) 콜백. 이 콜백은 작은 n에서는 여전히 신속하게 실행되지만, 큰 n에서는 이전 O(n) 예시보다 훨씬 느리게 실행됩니다.

```js
app.get('/countToN2', (req, res) => {
  let n = req.query.n;

  // n^2 반복 후 다른 클라이언트에게 차례를 줍니다
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      console.log(`Iter ${i}.${j}`);
    }
  }

  res.sendStatus(200);
});
```

### 얼마나 신경 써야 할까요?

Node.js는 많은 일반적인 작업에 대해 매우 빠른 Google V8 엔진을 사용합니다.
이 규칙의 예외는 아래에서 논의할 정규 표현식(Regexp) 및 JSON 작업입니다.

그러나 복잡한 작업의 경우 입력을 제한하고 너무 긴 입력을 거부하는 것을 고려해야 합니다.
이렇게 하면 콜백의 복잡도가 크더라도 입력을 제한함으로써 콜백이 최장 허용 입력에 대해 최악의 시간 이상을 소모하지 않도록 보장할 수 있습니다.
그런 다음 이 콜백의 최악의 경우 비용을 평가하고 실행 시간이 해당 맥락에서 허용 가능한지 여부를 결정할 수 있습니다.

### 이벤트 루프 차단: REDOS

이벤트 루프를 재앙적으로 차단하는 일반적인 방법 중 하나는 "취약한" [정규 표현식](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)을 사용하는 것입니다.

#### 취약한 정규 표현식 피하기

정규 표현식(Regexp)은 입력 문자열을 패턴과 비교합니다.
우리는 일반적으로 정규 표현식 매치가 입력 문자열을 한 번 통과하면 된다고 생각합니다 --- `O(n)` 시간, 여기서 `n`은 입력 문자열의 길이입니다.
많은 경우에 한 번 통과하는 것만으로도 충분합니다.
불행히도, 일부 경우에는 정규 표현식 매치가 입력 문자열을 지수적으로 여러 번 통과해야 할 수 있습니다 --- `O(2^n)` 시간.
지수적인 통과는 엔진이 매치를 결정하는 데 `x`번의 통과가 필요하면, 입력 문자열에 단 하나의 문자를 더 추가해도 `2*x`번의 통과가 필요함을 의미합니다.
통과 횟수가 시간과 선형적으로 연관되어 있으므로 이러한 평가의 결과는 이벤트 루프를 차단하게 됩니다.

*취약한 정규 표현식*은 정규 표현식 엔진이 지수적 시간이 소요될 수 있는 정규 표현식으로, "악성 입력"에 대해 [REDOS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)에 노출될 수 있습니다.
정규 표현식 패턴이 취약한지 여부(즉, 정규 표현식 엔진이 해당 패턴에 대해 지수 시간을 소모할 가능성이 있는지)는 실제로 답하기 어려운 질문이며 Perl, Python, Ruby, Java, JavaScript 등 사용 중인 언어에 따라 다릅니다.
하지만 모든 언어에 공통으로 적용되는 몇 가지 일반적인 규칙이 있습니다:

1. `(a+)*`와 같은 중첩된 수량자를 피하세요. V8의 정규 표현식 엔진은 일부 중첩을 빠르게 처리할 수 있지만, 다른 것들은 취약합니다.
2. `(a|a)*`와 같은 겹치는 OR 절을 피하세요. 이것도 때때로 빠릅니다.
3. `(a.*) \1`과 같은 역참조 사용을 피하세요. 어떤 정규 표현식 엔진도 이를 선형 시간에 평가할 수 있다고 보장할 수 없습니다.
4. 단순한 문자열 매치를 수행할 경우, `indexOf` 또는 로컬에서 사용할 수 있는 동등한 기능을 사용하세요. 이것은 더 저렴하며 `O(n)` 이상 시간이 소요되지 않습니다.

정규 표현식이 취약한지 확실하지 않다면, Node.js는 일반적으로 취약한 정규 표현식 및 긴 입력 문자열에 대해서도 *매치*를 보고하는 데 문제가 없다는 점을 기억하세요.
지수적 동작은 불일치가 발생했을 때 Node.js가 여러 경로를 시도할 때까지 확신할 수 없을 때 촉발됩니다.

#### REDOS 예시

다음은 서버를 REDOS에 노출시키는 취약한 정규 표현식 예시입니다:

```js
app.get('/redos-me', (req, res) => {
  let filePath = req.query.filePath;

  // REDOS
  if (filePath.match(/(\/.+)+$/)) {
    console.log('valid path');
  } else {
    console.log('invalid path');
  }

  res.sendStatus(200);
});
```

이 예시의 취약한 정규 표현식은 Linux에서 경로를 확인하는 (나쁜!) 방법입니다.
이것은 "/a/b/c"와 같이 "/"로 구분된 이름들의 연속 문자열을 매칭합니다.
이것은 규칙 1을 위반하기 때문에 위험합니다: 이 표현식은 이중으로 중첩된 수량자를 가지고 있습니다.

클라이언트가 `///.../\n`(100개의 / 뒤에 정규 표현식의 "."과 일치하지 않는 개행 문자)을 포함하는 filePath로 쿼리하면, 이벤트 루프가 사실상 무한정 차단되어 다른 클라이언트는 이 정규 표현식 매치가 끝날 때까지 차례를 얻지 못합니다.
이 클라이언트의 REDOS 공격은 정규 표현식 매치가 끝날 때까지 다른 모든 클라이언트가 차례를 얻지 못하게 합니다.

이러한 이유로 사용자 입력을 검증하는 데 복잡한 정규 표현식을 사용하는 것을 경계해야 합니다.

#### Anti-REDOS 리소스

정규 표현식의 안전성을 확인하는 데 사용할 수 있는 몇 가지 도구가 있습니다:

- [safe-regex](https://github.com/davisjam/safe-regex)
- [rxxr2](https://github.com/superhuman/rxxr2)

그러나 이러한 도구들은 모든 취약한 정규 표현식을 잡아내지 못할 수 있습니다.

다른 접근 방식은 다른 정규 표현식 엔진을 사용하는 것입니다.
[RE2](https://github.com/google/re2) 정규 표현식 엔진을 사용하는 [node-re2](https://github.com/uhop/node-re2) 모듈을 사용할 수 있습니다.
하지만 RE2는 V8의 정규 표현식과 100% 호환되지 않으므로, node-re2 모듈을 사용하여 정규 표현식을 처리할 때 회귀 문제가 발생하지 않는지 확인해야 합니다.
또한 특히 복잡한 정규 표현식은 node-re2에서 지원되지 않습니다.

URL이나 파일 경로와 같이 "명백한" 것을 매칭하려는 경우, [정규 표현식 라이브러리](http://www.regexlib.com)에서 예시를 찾거나 [ip-regex](https://www.npmjs.com/package/ip-regex)와 같은 npm 모듈을 사용하는 것이 좋습니다.

### 이벤트 루프 차단: Node.js 코어 모듈

여러 Node.js 코어 모듈에는 동기적이고 비용이 많이 드는 API가 포함되어 있습니다. 예를 들면:

- [암호화](https://nodejs.org/api/crypto.html)
- [압축](https://nodejs.org/api/zlib.html)
- [파일 시스템](https://nodejs.org/api/fs.html)
- [자식 프로세스](https://nodejs.org/api/child_process.html)

이러한 API는 상당한 계산(암호화, 압축)이 필요하거나 I/O가 필요(파일 I/O)하며, 때로는 둘 다 필요한 경우(자식 프로세스)가 있기 때문에 비용이 많이 듭니다.
이 API는 스크립팅 편의성을 위해 제공되지만, 서버 환경에서 사용하도록 설계된 것은 아닙니다.
이벤트 루프에서 이를 실행하면 일반적인 JavaScript 명령보다 훨씬 오래 걸리며, 이벤트 루프를 차단할 수 있습니다.

서버에서는 _다음 동기 API를 사용하지 말아야 합니다_:

- 암호화:
  - `crypto.randomBytes` (동기 버전)
  - `crypto.randomFillSync`
  - `crypto.pbkdf2Sync`
  - 또한 암호화 및 복호화 루틴에 큰 입력을 제공하는 것에 주의해야 합니다.
- 압축:
  - `zlib.inflateSync`
  - `zlib.deflateSync`
- 파일 시스템:
  - 동기 파일 시스템 API를 사용하지 마세요. 예를 들어, 파일이 [분산 파일 시스템](https://en.wikipedia.org/wiki/Clustered_file_system#Distributed_file_systems)에서 액세스되는 경우(NFS와 같은) 액세스 시간이 크게 달라질 수 있습니다.
- 자식 프로세스:
  - `child_process.spawnSync`
  - `child_process.execSync`
  - `child_process.execFileSync`

이 목록은 Node.js v9 기준으로 적절하게 완성되었습니다.

### 이벤트 루프 차단: JSON DOS

`JSON.parse` 및 `JSON.stringify`는 다른 잠재적으로 비용이 많이 드는 작업입니다.
이들은 입력 길이에 대해 `O(n)`이지만, `n`이 클 경우 놀랍게도 오랜 시간이 걸릴 수 있습니다.

서버에서 특히 클라이언트로부터 JSON 객체를 조작할 경우, 이벤트 루프에서 다루는 객체나 문자열의 크기에 주의해야 합니다.

예시: JSON 차단. 크기 2^21의 객체 `obj`를 생성하고 이를 `JSON.stringify`한 다음 문자열에서 `indexOf`를 실행한 후 이를 다시 `JSON.parse`합니다.
`JSON.stringify`된 문자열은 50MB입니다. 객체를 문자열로 변환하는 데 0.7초, 50MB 문자열에서 indexOf를 수행하는 데 0.03초, 문자열을 다시 구문 분석하는 데 1.3초가 소요됩니다.

```js
let obj = { a: 1 };
let niter = 20;

let before, str, pos, res, took;

for (let i = 0; i < niter; i++) {
  obj = { obj1: obj, obj2: obj }; // Doubles in size each iter
}

before = process.hrtime();
str = JSON.stringify(obj);
took = process.hrtime(before);
console.log('JSON.stringify took ' + took);

before = process.hrtime();
pos = str.indexOf('nomatch');
took = process.hrtime(before);
console.log('Pure indexof took ' + took);

before = process.hrtime();
res = JSON.parse(str);
took = process.hrtime(before);
console.log('JSON.parse took ' + took);
```

비동기 JSON API를 제공하는 npm 모듈도 있습니다. 예를 들어:

- [JSONStream](https://www.npmjs.com/package/JSONStream)은 스트림 API를 제공합니다.
- [Big-Friendly JSON](https://www.npmjs.com/package/bfj)은 스트림 API뿐만 아니라 이벤트 루프에서 파티셔닝하는 비동기 버전의 표준 JSON API도 제공합니다.

### 이벤트 루프를 차단하지 않고 복잡한 계산 수행

복잡한 계산을 JavaScript에서 수행하면서 이벤트 루프를 차단하지 않으려면 두 가지 옵션이 있습니다: 분할 또는 오프로딩입니다.

#### 분할(Partitioning)

계산 작업을 *분할*하여 각 작업을 이벤트 루프에서 실행하면서 주기적으로 다른 대기 중인 이벤트에 차례를 양보할 수 있습니다. JavaScript에서는 클로저(closure)에 진행 중인 작업의 상태를 쉽게 저장할 수 있으며, 아래의 예시 2에서 이를 확인할 수 있습니다.

간단한 예로, 1부터 `n`까지의 숫자의 평균을 계산한다고 가정해봅시다.

예시 1: 분할되지 않은 평균 계산, `O(n)`의 비용이 듭니다.

```js
for (let i = 0; i < n; i++) sum += i;
let avg = sum / n;
console.log('avg: ' + avg);
```

예시 2: 분할된 평균 계산, `n`개의 비동기 단계 각각의 비용은 `O(1)`입니다.

```js
function asyncAvg(n, avgCB) {
  // 진행 중인 합계를 JS 클로저에 저장합니다.
  let sum = 0;
  function help(i, cb) {
    sum += i;
    if (i == n) {
      cb(sum);
      return;
    }

    // "비동기 재귀".
    // 다음 작업을 비동기적으로 예약합니다.
    setImmediate(help.bind(null, i + 1, cb));
  }

  // 헬퍼를 시작하고, 콜백으로 avgCB를 호출합니다.
  help(1, function (sum) {
    let avg = sum / n;
    avgCB(avg);
  });
}

asyncAvg(n, function (avg) {
  console.log('avg of 1-n: ' + avg);
});
```

이 원리는 배열 반복 작업 등에 적용할 수 있습니다.

#### 오프로딩(Offloading)

더 복잡한 작업을 해야 한다면 분할은 좋은 옵션이 아닙니다. 분할은 이벤트 루프만을 사용하므로, 거의 항상 사용 가능한 여러 코어의 이점을 누리지 못하게 됩니다. _이벤트 루프는 클라이언트 요청을 조정해야지, 직접 처리하는 역할을 맡지 않도록 해야 합니다._
복잡한 작업의 경우, 이벤트 루프에서 해당 작업을 내려놓고 워커 풀로 작업을 넘기는 것이 좋습니다.

##### 오프로딩 방법

작업을 넘길 수 있는 워커 풀에는 두 가지 옵션이 있습니다.

1. [C++ 애드온](https://nodejs.org/api/addons.html)을 개발하여 Node.js 내장 워커 풀을 사용할 수 있습니다. 오래된 Node 버전에서는 [NAN](https://github.com/nodejs/nan)을 사용해 C++ 애드온을 빌드하고, 새로운 버전에서는 [N-API](https://nodejs.org/api/n-api.html)를 사용합니다. [node-webworker-threads](https://www.npmjs.com/package/webworker-threads)는 Node.js 워커 풀에 접근할 수 있는 JavaScript 전용 방법을 제공합니다.
2. Node.js의 I/O 중심 워커 풀 대신에 계산 전용 워커 풀을 직접 생성하고 관리할 수 있습니다. 가장 간단한 방법은 [Child Process](https://nodejs.org/api/child_process.html)나 [Cluster](https://nodejs.org/api/cluster.html)를 사용하는 것입니다.

모든 클라이언트에 대해 [Child Process](https://nodejs.org/api/child_process.html)를 단순히 생성해서는 _안 됩니다_. 클라이언트 요청을 처리하는 속도보다 프로세스를 생성하고 관리하는 속도가 느려질 수 있으며, 서버가 [포크 폭탄](https://en.wikipedia.org/wiki/Fork_bomb)이 될 수 있습니다.

##### 오프로딩의 단점

오프로딩 방식의 단점은 *통신 비용*이라는 오버헤드가 발생한다는 점입니다. 오직 이벤트 루프만이 애플리케이션의 "네임스페이스"(JavaScript 상태)를 볼 수 있습니다. 워커에서는 이벤트 루프의 네임스페이스 내 JavaScript 객체를 조작할 수 없습니다. 대신 공유하려는 모든 객체를 직렬화하고 역직렬화해야 합니다. 그 후 워커는 해당 객체의 사본에서 작업을 수행하고, 수정된 객체(또는 "패치")를 이벤트 루프로 반환할 수 있습니다.

직렬화와 관련된 문제는 JSON DOS 섹션을 참조하세요.

##### 오프로딩에 대한 몇 가지 제안

CPU 집약적인 작업과 I/O 집약적인 작업을 구분하는 것이 좋습니다. 두 작업은 특성이 매우 다르기 때문입니다.

CPU 집약적인 작업은 워커가 스케줄링될 때만 진전이 있으며, 워커는 컴퓨터의 [논리 코어](https://nodejs.org/api/os.html#os_os_cpus) 중 하나에 스케줄링되어야 합니다. 예를 들어, 4개의 논리 코어가 있고 5개의 워커가 있는 경우, 이들 중 하나의 워커는 진전할 수 없습니다. 결과적으로, 이 워커의 메모리와 스케줄링 비용은 발생하지만 아무런 성과를 얻지 못하게 됩니다.

I/O 집약적인 작업은 외부 서비스 제공자(DNS, 파일 시스템 등)에 요청을 보내고 응답을 기다리는 작업입니다. I/O 집약적인 작업을 수행하는 워커는 응답을 기다리는 동안 할 일이 없으므로, 운영 체제에서 해당 워커를 비스케줄링하여 다른 워커가 요청을 제출할 기회를 줄 수 있습니다. _따라서 I/O 집약적인 작업은 해당 스레드가 실행되지 않는 동안에도 진행되고 있을 것입니다._ 데이터베이스나 파일 시스템과 같은 외부 서비스 제공자는 동시에 여러 대기 중인 요청을 처리하도록 고도로 최적화되어 있습니다. 예를 들어, 파일 시스템은 대기 중인 대량의 읽기 및 쓰기 요청을 조사하여 충돌하는 업데이트를 병합하고, 최적의 순서로 파일을 검색합니다.

하나의 워커 풀만 사용하고 있는 경우, 예를 들어 Node.js 워커 풀만 사용한다면, CPU 바인딩 작업과 I/O 바인딩 작업의 특성 차이가 애플리케이션 성능에 악영향을 미칠 수 있습니다.

이러한 이유로 별도의 계산 워커 풀을 유지하는 것이 좋습니다.

#### 오프로딩: 결론

긴 배열의 요소를 반복하는 것과 같은 간단한 작업의 경우 분할이 좋은 선택일 수 있습니다. 하지만 계산이 더 복잡한 경우, 오프로딩이 더 나은 방법입니다. 즉, 이벤트 루프와 워커 풀 간의 직렬화된 객체를 전달하는 데 드는 통신 비용은 여러 코어를 사용할 수 있는 이점으로 상쇄됩니다.

그러나 서버가 복잡한 계산에 많이 의존하는 경우, Node.js가 정말 적합한 선택인지 고민해보는 것이 좋습니다. Node.js는 I/O 중심 작업에서 뛰어나지만, 비싼 계산에는 적합하지 않을 수 있습니다.

오프로딩 방식을 선택한 경우, 워커 풀을 차단하지 않는 방법에 대한 섹션을 참조하세요.

## 워커 풀을 차단하지 마세요

Node.js에는 `k`개의 워커로 구성된 워커 풀이 있습니다. 앞에서 설명한 오프로딩 패러다임을 사용하고 있는 경우 별도의 계산 워커 풀을 가지고 있을 수 있으며, 동일한 원칙이 적용됩니다. 어느 경우든 `k`는 동시에 처리할 수 있는 클라이언트 수보다 훨씬 적다고 가정해야 합니다. 이는 Node.js의 "한 스레드로 여러 클라이언트를 처리하는" 철학과 일치하며, 확장성의 비결이기도 합니다.

앞서 논의한 바와 같이, 각 워커는 워커 풀 대기열에 있는 다음 작업을 처리하기 전에 현재 작업을 완료합니다.

이제 클라이언트 요청을 처리하는 데 필요한 작업의 비용에 변동이 있을 수 있습니다. 일부 작업은 빠르게 완료되며(예: 짧거나 캐시된 파일 읽기, 적은 수의 랜덤 바이트 생성), 일부 작업은 시간이 더 오래 걸립니다(예: 더 크거나 캐시되지 않은 파일 읽기, 더 많은 랜덤 바이트 생성). 목표는 *작업 시간의 변동을 최소화하는 것*이며, 이를 위해 *작업 분할*을 사용해야 합니다.

### 작업 시간 변동 최소화

만약 한 워커의 현재 작업이 다른 작업들보다 훨씬 더 많은 비용을 필요로 한다면, 해당 워커는 완료될 때까지 다른 대기 중인 작업들을 처리할 수 없습니다. 즉, _상대적으로 긴 작업은 완료될 때까지 워커 풀의 크기를 하나 줄이는 효과가 있습니다_. 이는 바람직하지 않은데, 이유는 어느 정도까지는 워커 풀이 클수록 워커 풀의 처리량(작업/초)이 증가하고, 이는 서버의 처리량(클라이언트 요청/초)을 증가시키기 때문입니다. 상대적으로 비용이 큰 작업을 가진 한 클라이언트는 워커 풀의 처리량을 줄이고, 결과적으로 서버의 처리량도 감소시킵니다.

이를 방지하려면 워커 풀에 제출하는 작업의 길이 변동을 최소화하려고 노력해야 합니다. I/O 요청(DB, 파일 시스템 등)으로 액세스하는 외부 시스템을 블랙 박스로 취급하는 것은 적절하지만, 이러한 I/O 요청의 상대적 비용을 알고 있어야 하며, 특히 긴 작업이 예상되는 요청을 제출하지 않도록 해야 합니다.

두 가지 예를 통해 작업 시간의 변동 가능성을 설명하겠습니다.

#### 변동 예시: 오래 걸리는 파일 시스템 읽기

서버가 일부 클라이언트 요청을 처리하기 위해 파일을 읽어야 한다고 가정해봅시다. Node.js [파일 시스템](https://nodejs.org/api/fs.html) API를 참조한 후, 간편함을 위해 `fs.readFile()`을 사용하기로 결정했습니다. 그러나 `fs.readFile()`은 ([현재](https://github.com/nodejs/node/pull/17054)) 파티셔닝되지 않았습니다: 전체 파일을 아우르는 단일 `fs.read()` 작업을 제출합니다. 어떤 사용자는 짧은 파일을, 다른 사용자는 긴 파일을 읽는다면, `fs.readFile()`은 작업 길이에 상당한 변동을 도입하여 워커 풀 처리량에 악영향을 미칠 수 있습니다.

최악의 경우를 가정해 보겠습니다. 공격자가 서버가 임의의 파일을 읽도록 유도할 수 있다면(이것은 [디렉터리 탐색 취약성](https://www.owasp.org/index.php/Path_Traversal)입니다), 서버가 리눅스에서 실행 중일 때, 공격자는 매우 느린 파일인 [`/dev/random`](http://man7.org/linux/man-pages/man4/random.4.html)을 지명할 수 있습니다. `/dev/random`은 실질적으로 무한히 느리며, `/dev/random`에서 읽기를 요청받은 모든 워커는 해당 작업을 절대 완료하지 못합니다. 그 후 공격자가 워커마다 하나씩 `k` 개의 요청을 제출하면 워커 풀을 사용하는 다른 클라이언트 요청은 더 이상 진행되지 않습니다.

#### 변동 예시: 오래 걸리는 암호화 작업

서버가 [`crypto.randomBytes()`](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)를 사용해 암호학적으로 안전한 무작위 바이트를 생성한다고 가정해 봅시다. `crypto.randomBytes()`는 파티셔닝되지 않았으며, 요청한 만큼의 바이트를 생성하는 단일 `randomBytes()` 작업을 만듭니다. 어떤 사용자는 더 적은 바이트를, 다른 사용자는 더 많은 바이트를 생성한다면, `crypto.randomBytes()`도 작업 길이 변동의 또 다른 원천이 됩니다.

### 작업 파티셔닝

시간 비용이 가변적인 작업은 워커 풀의 처리량에 해를 끼칠 수 있습니다. 작업 시간을 가능한 한 최소화하려면, _비교 가능한 비용의 하위 작업들로 작업을 분할_ 해야 합니다. 각 하위 작업이 완료되면 다음 하위 작업을 제출하고, 마지막 하위 작업이 완료되면 제출자에게 알림을 보냅니다.

`fs.readFile()` 예를 계속해서 설명하자면, 대신 `fs.read()`(수동 파티셔닝) 또는 `ReadStream`(자동 파티셔닝)을 사용해야 합니다.

같은 원칙이 CPU에 의존적인 작업에도 적용됩니다. `asyncAvg` 예시는 이벤트 루프에는 부적합할 수 있지만 워커 풀에는 적합합니다.

작업을 하위 작업들로 분할하면, 짧은 작업은 소수의 하위 작업들로 확장되고, 긴 작업은 다수의 하위 작업들로 확장됩니다. 긴 작업의 각 하위 작업 사이에, 작업이 할당된 워커는 다른 더 짧은 작업의 하위 작업을 처리할 수 있으므로 워커 풀 전체의 작업 처리량을 개선할 수 있습니다.

완료된 하위 작업의 수는 워커 풀의 처리량에 대한 유용한 척도가 아닙니다. 대신, 완료된 _작업_ 수에 집중해야 합니다.

### 작업 파티셔닝 피하기

작업 파티셔닝의 목적은 작업 시간의 변동을 최소화하는 것입니다. 짧은 작업과 긴 작업을 구별할 수 있다면(예: 배열 합산과 배열 정렬), 작업 클래스마다 별도의 워커 풀을 만들 수 있습니다. 짧은 작업과 긴 작업을 별도의 워커 풀로 라우팅하는 것은 작업 시간 변동을 최소화하는 또 다른 방법입니다.

이 접근 방식을 지지하는 이유는, 작업 파티셔닝은 워커 풀 작업 표현 생성 및 워커 풀 큐 조작의 비용을 수반하며, 파티셔닝을 피함으로써 워커 풀로의 추가 왕복 비용을 절약할 수 있다는 점입니다. 또한 작업을 파티셔닝할 때 발생할 수 있는 실수를 방지할 수 있습니다.

이 접근 방식의 단점은 모든 워커 풀의 워커들이 공간 및 시간 오버헤드를 수반하고, 서로 CPU 시간을 놓고 경쟁하게 된다는 것입니다. 각 CPU 기반 작업은 스케줄링될 때만 진행된다는 점을 기억하십시오. 결과적으로, 이 접근 방식을 고려하기 전에 신중한 분석이 필요합니다.

### 워커 풀: 결론

Node.js 워커 풀만 사용하든, 별도의 워커 풀을 유지하든, 워커 풀의 작업 처리량을 최적화해야 합니다.

이를 위해 작업 파티셔닝을 사용하여 작업 시간 변동을 최소화하십시오.

## npm 모듈의 위험성

Node.js 핵심 모듈은 다양한 애플리케이션의 빌딩 블록을 제공하지만, 때로는 그 이상이 필요합니다. Node.js 개발자는 [npm 생태계](https://www.npmjs.com/) 덕분에 개발 프로세스를 가속화할 수 있는 수많은 모듈로부터 엄청난 혜택을 얻습니다.

그러나 대부분의 모듈은 제3자 개발자가 작성하며, 일반적으로 최선의 노력 보증만 제공된다는 점을 기억하십시오. npm 모듈을 사용하는 개발자는 두 가지를 염두에 두어야 합니다. 하지만 두 번째는 자주 잊혀집니다.

1. API를 준수하는가?
2. API가 이벤트 루프나 워커를 차단할 수 있는가?
   많은 모듈은 그들의 API 비용을 표시하려고 하지 않아 커뮤니티에 해를 끼칩니다.

단순한 API의 경우 API의 비용을 예측할 수 있습니다. 문자열 조작의 비용은 이해하기 어렵지 않습니다. 하지만 많은 경우 API가 얼마나 비용이 들지 명확하지 않습니다.

_비용이 많이 들 수 있는 API를 호출할 경우, 반드시 비용을 다시 확인하십시오. 개발자에게 문서화를 요청하거나, 직접 소스 코드를 살펴보고(비용을 문서화하는 PR을 제출하십시오)._

API가 비동기적일지라도, 각 파티션에서 해당 API가 워커 또는 이벤트 루프에서 얼마나 많은 시간을 소비할지 알 수 없습니다. 예를 들어 위의 `asyncAvg` 예시에서, 보조 함수 호출이 숫자의 *절반*을 합산했다면 어떻게 될까요? 이 함수는 여전히 비동기적일 것이지만, 각 파티션의 비용은 `O(n)`이 되어, 임의의 `n` 값에 대해 사용하기 훨씬 덜 안전해질 것입니다.

## 결론

Node.js에는 두 가지 유형의 스레드가 있습니다: 하나의 이벤트 루프와 `k` 개의 워커. 이벤트 루프는 자바스크립트 콜백 및 논블로킹 I/O를 담당하며, 워커는 비동기 요청을 완료하는 C++ 코드에 해당하는 작업을 실행합니다. 여기에는 블로킹 I/O 및 CPU 집약적인 작업이 포함됩니다. 두 스레드 유형 모두 동시에 하나 이상의 활동을 처리하지 않습니다. 콜백이나 작업이 오래 걸리면 해당 작업을 실행하는 스레드는 *차단*됩니다. 차단되는 콜백이나 작업을 만들면 최선의 경우 처리량(클라이언트/초)이 저하되고, 최악의 경우 서비스 거부(DOS)로 이어질 수 있습니다.

고 처리량, 더 DoS 방지형 웹 서버를 작성하려면, 악의적이든 그렇지 않든 모든 입력에서 이벤트 루프나 워커가 차단되지 않도록 해야 합니다.
