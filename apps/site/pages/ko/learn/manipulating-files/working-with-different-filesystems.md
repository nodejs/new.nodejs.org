---
title: 다양한 파일 시스템 작업하기
layout: learn
---

# 다양한 파일 시스템 작업하기

Node.js는 파일 시스템의 많은 기능을 노출합니다. 하지만 모든 파일 시스템이 동일하지는 않습니다.
다음은 다양한 파일 시스템을 다룰 때 코드를 간단하고 안전하게 유지하기 위한 권장 모범 사례입니다.

## 파일 시스템 동작

파일 시스템을 사용하기 전에, 해당 파일 시스템이 어떻게 동작하는지 알아야 합니다.
파일 시스템마다 기능이 다르며, 대소문자 구분, 대소문자 비구분, 대소문자 보존, 유니코드 형식 보존, 타임스탬프 해상도, 확장 속성, inode, Unix 권한, 대체 데이터 스트림 등의 기능 차이가 있습니다.

`process.platform`으로부터 파일 시스템의 동작을 추론하지 않도록 주의하세요. 예를 들어, 프로그램이 다윈(Darwin)에서 실행되고 있다고 해서 반드시 대소문자를 구분하지 않는 파일 시스템(HFS+)에서 작동한다고 단정하지 마세요. 사용자가 대소문자를 구분하는 파일 시스템(HFSX)을 사용하고 있을 수도 있습니다. 마찬가지로, 프로그램이 리눅스에서 실행되고 있다고 해서 Unix 권한과 inode를 지원하는 파일 시스템에서 작업한다고 단정할 수 없습니다. 외부 드라이브, USB, 네트워크 드라이브와 같은 파일 시스템은 이러한 기능을 지원하지 않을 수 있습니다.

운영 체제가 파일 시스템 동작을 추론하는 것을 쉽게 만들지 않지만, 방법이 없는 것은 아닙니다. 모든 알려진 파일 시스템과 동작 목록을 유지하는 대신, 파일 시스템이 실제로 어떻게 동작하는지 직접 확인할 수 있습니다. 일부 기능의 존재 여부만 확인해도, 확인하기 어려운 다른 기능의 동작을 유추할 수 있습니다.

사용자가 작업 트리의 다양한 경로에 서로 다른 파일 시스템을 마운트할 수 있다는 점을 기억하세요.

## 최소 공통 분모 접근 방식을 피하세요

프로그램을 최소 공통 분모 파일 시스템처럼 작동하도록 만들어, 모든 파일명을 대문자로 정규화하고, 모든 파일명을 NFC 유니코드 형식으로 정규화하며, 모든 파일 타임스탬프를 1초 해상도로 정규화하는 유혹에 빠질 수 있습니다. 이는 최소 공통 분모 접근 방식입니다.

이렇게 하지 마세요. 이러한 방식은 정확히 동일한 최소 공통 분모 특성을 가진 파일 시스템에서만 안전하게 상호작용할 수 있게 할 뿐입니다. 더 고급 파일 시스템과는 사용자가 기대하는 방식으로 작업할 수 없게 되고, 파일 이름이나 타임스탬프 충돌을 겪게 됩니다. 복잡한 의존성 이벤트를 통해 사용자 데이터를 잃고 손상시키며, 해결하기 어렵거나 불가능한 버그를 만들게 될 것입니다.

나중에 2초 또는 24시간 타임스탬프 해상도만 지원하는 파일 시스템을 지원해야 한다면 어떻게 될까요? 유니코드 표준이 약간 다른 정규화 알고리즘을 포함하도록 발전하면 어떻게 될까요?

최소 공통 분모 접근 방식은 "이식 가능한" 시스템 호출만을 사용하여 이식 가능한 프로그램을 만들려는 경향이 있습니다. 그러나 이것은 누수성이 있는 프로그램을 만들며 실제로 이식 가능하지 않습니다.

## 상위 집합 접근 방식 채택

각 플랫폼을 최대한 활용하여 상위 집합 접근 방식을 채택하세요. 예를 들어, 이식 가능한 백업 프로그램은 Windows 시스템 간에 btimes(파일 또는 폴더의 생성 시간)를 올바르게 동기화해야 하며, Linux 시스템에서는 btimes가 지원되지 않더라도 이를 파괴하거나 변경하지 않아야 합니다. 동일한 이식 가능한 백업 프로그램은 Linux 시스템 간에 Unix 권한을 올바르게 동기화해야 하며, Windows 시스템에서는 Unix 권한이 지원되지 않더라도 이를 파괴하거나 변경하지 않아야 합니다.

각 파일 시스템이 제공하는 기능을 최대로 지원하는 프로그램을 만드세요. 대소문자 구분, 대소문자 보존, 유니코드 형식 민감성, 유니코드 형식 보존, Unix 권한, 고해상도 나노초 타임스탬프, 확장 속성 등을 지원해야 합니다.

대소문자 보존이 프로그램에 도입되면, 대소문자를 구분하지 않는 파일 시스템과 상호작용해야 할 때 대소문자 구분 기능을 쉽게 구현할 수 있습니다. 그러나 대소문자 보존을 생략하면 대소문자를 보존하는 파일 시스템과 안전하게 상호작용할 수 없습니다. 유니코드 형식 보존과 타임스탬프 해상도 보존도 마찬가지입니다.

파일 시스템이 혼합된 대소문자로 파일명을 제공하면, 제공된 정확한 대소문자 그대로 파일명을 유지하세요. 파일 시스템이 혼합된 유니코드 형식이나 NFC 또는 NFD(또는 NFKC 또는 NFKD)로 파일명을 제공하면, 제공된 정확한 바이트 시퀀스 그대로 파일명을 유지하세요. 파일 시스템이 밀리초 타임스탬프를 제공하면, 밀리초 해상도로 타임스탬프를 유지하세요.

더 낮은 파일 시스템과 작업할 때는 비교 기능을 통해 적절히 다운샘플링할 수 있습니다. 파일 시스템이 Unix 권한을 지원하지 않는다는 것을 알고 있다면, 작성한 동일한 Unix 권한을 읽을 수 있을 것으로 기대하지 마세요. 파일 시스템이 대소문자를 보존하지 않는다는 것을 알고 있다면, 프로그램이 `abc`를 생성할 때 디렉터리 목록에서 `ABC`를 볼 수 있을 것으로 준비해야 합니다. 그러나 파일 시스템이 대소문자를 보존한다는 것을 알고 있다면, 파일 이름을 감지할 때 `ABC`와 `abc`를 다른 파일 이름으로 간주해야 합니다.

## 대소문자 보존

`test/abc`라는 디렉터리를 만들었을 때, `fs.readdir('test')`가 때때로 `['ABC']`를 반환하는 것을 보고 놀랄 수 있습니다. 이는 Node.js의 버그가 아닙니다. Node.js는 파일 시스템이 저장하는 대로 파일 이름을 반환하며, 모든 파일 시스템이 대소문자 보존을 지원하는 것은 아닙니다. 일부 파일 시스템은 모든 파일 이름을 대문자(또는 소문자)로 변환합니다.

## 유니코드 형식 보존

_대소문자 보존과 유니코드 형식 보존은 유사한 개념입니다. 유니코드 형식이 왜 보존되어야 하는지를 이해하려면, 먼저 대소문자가 왜 보존되어야 하는지를 이해해야 합니다. 유니코드 형식 보존은 올바르게 이해하면 매우 간단합니다._

유니코드는 여러 가지 다른 바이트 시퀀스를 사용하여 동일한 문자를 인코딩할 수 있습니다. 여러 문자열이 동일하게 보일 수 있지만, 바이트 시퀀스는 다를 수 있습니다. UTF-8 문자열을 다룰 때는 유니코드가 어떻게 작동하는지에 대한 기대치가 일치하는지 주의하세요. 모든 UTF-8 문자가 단일 바이트로 인코딩될 것이라는 기대를 하지 않듯이, 동일하게 보이는 여러 UTF-8 문자열이 동일한 바이트 표현을 가질 것이라는 기대도 하지 마세요. 이러한 기대는 ASCII에서는 가능하지만, UTF-8에서는 그렇지 않습니다.

`test/café`라는 디렉터리(NFC 유니코드 형식, 바이트 시퀀스 `<63 61 66 c3 a9>` 및 `string.length === 5`)를 만들었을 때, `fs.readdir('test')`가 때때로 `['café']`(NFD 유니코드 형식, 바이트 시퀀스 `<63 61 66 65 cc 81>` 및 `string.length === 6`)를 반환하는 것을 보고 놀랄 수 있습니다. 이는 Node.js의 버그가 아닙니다. Node.js는 파일 시스템이 저장하는 대로 파일 이름을 반환하며, 모든 파일 시스템이 유니코드 형식 보존을 지원하는 것은 아닙니다.

예를 들어, HFS+는 모든 파일 이름을 거의 항상 NFD 형식으로 정규화합니다. HFS+가 NTFS 또는 EXT4와 동일하게 동작할 것이라고 기대하지 마세요. 유니코드 차이를 보완하기 위해 데이터 정규화를 누수성 추상화로 처리하려 하지 마세요. 이로 인해 문제가 생기고, 해결할 수 없습니다. 대신, 유니코드 형식을 보존하고 비교 함수로서만 정규화를 사용하세요.

## 유니코드 형식 비구분

유니코드 형식 비구분과 유니코드 형식 보존은 서로 다른 파일 시스템 동작이며, 종종 혼동됩니다. 대소문자 비구분이 파일 이름을 저장하고 전송할 때 영구적으로 대문자로 정규화하는 방식으로 잘못 구현된 것처럼, 유니코드 형식 비구분도 종종 잘못 구현되어 유니코드 형식을 영구적으로 정규화(NFD의 경우 HFS+)하는 방식으로 저장 및 전송됩니다. 유니코드 형식 보존을 희생하지 않고도 유니코드 형식 비구분을 구현하는 것이 가능하며, 훨씬 더 좋습니다. 비교를 위해서만 유니코드 정규화를 사용하세요.

## 다른 유니코드 형식 비교

Node.js는 UTF-8 문자열을 NFC 또는 NFD로 정규화할 수 있는 `string.normalize('NFC' / 'NFD')`를 제공합니다. 이 함수의 출력을 저장하지 말고, 두 UTF-8 문자열이 사용자에게 동일하게 보일지 테스트하는 비교 함수의 일부로만 사용하세요.

`string1.normalize('NFC') === string2.normalize('NFC')` 또는 `string1.normalize('NFD') === string2.normalize('NFD')`를 비교 함수로 사용할 수 있습니다. 어떤 형식을 사용하는지는 중요하지 않습니다.

정규화는 빠르지만, 비교 함수에 입력할 캐시를 사용하는 것이 좋습니다. 동일한 문자열을 여러 번 정규화하는 것을 피할 수 있습니다. 캐시에 문자열이 없으면 정규화하고 캐시하세요. 캐시를 저장하거나 유지하지 않도록 주의하세요. 캐시로만 사용하세요.

`normalize()`를 사용하려면 Node.js 버전에 ICU가 포함되어 있어야 합니다. 그렇지 않으면 `normalize()`는 원래 문자열을 반환합니다. Node.js 최신 버전을 웹사이트에서 다운로드하면 ICU가 포함됩니다.

## 타임스탬프 해상도

파일의 `mtime`(수정 시간)을 `1444291759414`(밀리초 해상도)로 설정한 후, `fs.stat`가 새 mtime을 `1444291759000`(1초 해상도) 또는 `1444291758000`(2초 해상도)로 반환하는 것을 보고 놀랄 수 있습니다. 이는 Node.js의 버그가 아닙니다. Node.js는 파일 시스템이 저장하는 대로 타임스탬프를 반환하며, 모든 파일 시스템이 나노초, 밀리초 또는 1초 타임스탬프 해상도를 지원하는 것은 아닙니다. 일부 파일 시스템은 특히 atime 타임스탬프의 해상도가 매우 낮습니다(예: 일부 FAT 파일 시스템의 경우 24시간).

## 파일 이름과 타임스탬프를 정규화로 손상시키지 마세요

파일 이름과 타임스탬프는 사용자 데이터입니다. 데이터 파일을 대문자로 자동 변환하거나 `CRLF`를 `LF`로 자동 변환하지 않는 것처럼, 파일 이름이나 타임스탬프를 정규화로 변경하거나 간섭하거나 손상시키지 마세요. 정규화는 비교 용도로만 사용해야 하며, 데이터를 변경하는 용도로 사용해서는 안 됩니다.

정규화는 손실 해시 코드입니다. 여러 문자열이 서로 동일하게 보일지 테스트하는 특정 유형의 동등성을 확인하는 데 사용할 수 있지만, 실제 데이터의 대체물로 사용할 수는 없습니다. 프로그램은 파일 이름과 타임스탬프 데이터를 그대로 전달해야 합니다.

프로그램이 새로운 데이터를 NFC(또는 선호하는 유니코드 형식 조합)로 생성하거나, 대문자 또는 소문자로 된 파일 이름을 생성하거나, 2초 해상도 타임스탬프로 생성할 수 있지만, 프로그램이 대소문자/유니코드 형식/타임스탬프 정규화를 강요하여 기존 사용자 데이터를 손상시키지 않아야 합니다. 상위 집합 접근 방식을 채택하고 프로그램에서 대소문자, 유니코드 형식, 타임스탬프 해상도를 보존하세요. 이를 통해 동일하게 동작하는 파일 시스템과 안전하게 상호작용할 수 있습니다.

## 비교 함수 사용 시 적절한 정규화 사용

대소문자/유니코드 형식/타임스탬프 비교 함수를 적절히 사용하세요. 대소문자를 구분하는 파일 시스템에서 대소문자 비구분 파일 이름 비교 함수를 사용하지 마세요. 유니코드 형식을 보존하는 파일 시스템에서 유니코드 형식 비구분 비교 함수를 사용하지 마세요(예: NTFS 및 대부분의 Linux 파일 시스템은 NFC와 NFD 또는 혼합된 유니코드 형식을 모두 보존). 나노초 타임스탬프 해상도 파일 시스템에서 타임스탬프를 2초 해상도로 비교하지 마세요.

## 비교 함수에서 약간의 차이에 대비하세요

비교 함수가 파일 시스템과 일치하는지 확인하세요(또는 파일 시스템이 실제로 어떻게 비교하는지 확인하세요). 예를 들어, 대소문자 비구분은 단순한 `toLowerCase()` 비교보다 더 복잡합니다. 사실, `toUpperCase()`는 `toLowerCase()`보다 더 낫습니다(외국어 문자를 다르게 처리하기 때문에). 그러나 더 나은 방법은 파일 시스템을 확인하는 것이며, 각 파일 시스템은 자체적으로 대소문자 비교 표를 내장하고 있습니다.

예를 들어, Apple의 HFS+는 파일 이름을 NFD 형식으로 정규화하지만, 이 NFD 형식은 실제로 최신 NFD 형식과 약간 다를 수 있습니다. HFS+ NFD가 항상 최신 유니코드 표준의 NFD와 동일하다고 기대하지 마세요.
