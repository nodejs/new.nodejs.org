---
title: Sobre o Node.js®️
layout: about
---

<div className="meu-4 items-centro de justify-centro flex">
  <img
    alt="Mascote de Node.js"
    src="/static/images/node-mascot.svg"
    className="w-[100px]"
  />
</div>

---

# Sobre o Node.js®️

Como um assíncrono executivo JavaScript conduzido por eventos, o Node.js é projetado para construir aplicativos de rede
escalável. No seguinte exemplo do "olá mundo", muitas conexões
podem ser tratadas simultaneamente. Em cada conexão, o callback é disparado
, mas se não houver trabalho a ser feito, o Node.js irá dormir.

```js
const http = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Isso está em contraste com o modelo de concorrência mais comum de hoje, no qual os segmentos do sistema operacional
são empregados. A rede baseada em tópicos é relativamente ineficiente e muito
difícil de usar. Além disso, os usuários do Node.js estão livres de preocupações de um bloqueio
do processo, uma vez que não há bloqueios. Quase nenhuma função em
nó. s executa diretamente o I/O, então o processo nunca bloqueia, exceto quando o E/S é executado usando
métodos síncronos de Node. s biblioteca padrão. Como nada bloqueia, os sistemas escalonáveis são muito
razoáveis para desenvolver no Node.js.

Se algum desse idioma não é familiar, há um artigo completo no
\[Bloquear vs. Não Bloquear]\[].

---

Node.js é similar no design e influenciado por sistemas como o Ruby's
\[Máquina de Evento]\[] e o Python's \[Twisted]\[]. Node.js leva ainda mais o modelo de evento.
Apresenta um loop de evento como uma construção de tempo de execução em vez de como uma biblioteca. Em outros sistemas,
sempre há uma chamada de bloqueio para iniciar o loop de eventos.
Normalmente, o comportamento é definido através de callbacks no início de um script, e
no final, um servidor é iniciado através de uma chamada de bloqueio como `EventMachine::run()`.
Em Node.js, não há uma chamada inicial no loop. Node.js simplesmente entra no loop de eventos depois de executar o script de entrada. Node.js
sai do loop de evento quando não há mais callbacks para executar. Esse comportamento
é como JavaScript do navegador — o loop de eventos está oculto do usuário.

HTTP é um cidadão de primeira classe no Node.js, projetado com streaming e baixa latência em mente. Isso torna o Node.js bem adequado para a base de uma biblioteca ou framework web.

Node.js ser projetado sem threads não significa que você não possa tirar proveito de múltiplos núcleos em seu ambiente. Processos filhos podem ser criados usando nossa API \[`child_process.fork()`], e são projetados para serem fáceis de se comunicar. Baseado nessa mesma interface está o módulo \[`cluster`], que permite compartilhar sockets entre processos para habilitar o balanceamento de carga em seus núcleos.

[bloqueando vs. não-bloqueando]: /learn/asynchronous-work/overview-of-blocking-vs-non-block
[`processo_filho.fork()`]: https://nodejs.org/api/child_process.html
[`agrupamento`]: https://nodejs.org/api/cluster.html
[máquina do evento]: https://github.com/eventmachine/eventmachine
[torcido]: https://twistedmatrix.com/trac/
