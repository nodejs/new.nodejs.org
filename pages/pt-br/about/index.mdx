---
title: Sobre o Node.js®️
layout: about
---

<div className="meu-4 items-centro de justify-centro flex">
  <img
    alt="Mascote de Node.js"
    src="/static/images/node-mascot.svg"
    className="w-[100px]"
  />
</div>

---

# Sobre o Node.js®️

Como um assíncrono executivo JavaScript conduzido por eventos, o Node.js é projetado para construir aplicativos de rede
escalável. No seguinte exemplo do "olá mundo", muitas conexões
podem ser tratadas simultaneamente. Em cada conexão, o callback é disparado
, mas se não houver trabalho a ser feito, o Node.js irá dormir.

```js
const http = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Isso está em contraste com o modelo de concorrência mais comum de hoje, no qual os segmentos do sistema operacional
são empregados. A rede baseada em tópicos é relativamente ineficiente e muito
difícil de usar. Além disso, os usuários do Node.js estão livres de preocupações de um bloqueio
do processo, uma vez que não há bloqueios. Quase nenhuma função em
nó. s executa diretamente o I/O, então o processo nunca bloqueia, exceto quando o E/S é executado usando
métodos síncronos de Node. s biblioteca padrão. Como nada bloqueia, os sistemas escalonáveis são muito
razoáveis para desenvolver no Node.js.

Se algum desse idioma não é familiar, há um artigo completo no
\[Bloquear vs. Não Bloquear]\[].

---

Node.js é similar no design e influenciado por sistemas como o Ruby's
\[Máquina de Evento]\[] e o Python's \[Twisted]\[]. Node.js leva ainda mais o modelo de evento.
Apresenta um loop de evento como uma construção de tempo de execução em vez de como uma biblioteca. Em outros sistemas,
sempre há uma chamada de bloqueio para iniciar o loop de eventos.
Normalmente, o comportamento é definido através de callbacks no início de um script, e
no final, um servidor é iniciado através de uma chamada de bloqueio como `EventMachine::run()`.
Em Node.js, não há uma chamada inicial no loop. Node.js simplesmente entra no loop de eventos depois de executar o script de entrada. Node.js
sai do loop de evento quando não há mais callbacks para executar. Esse comportamento
é como JavaScript do navegador — o loop de eventos está oculto do usuário.

HTTP is a first-class citizen in Node.js, designed with streaming and low
latency in mind. This makes Node.js well suited for the foundation of a web
library or framework.

Node.js being designed without threads doesn't mean you can't take
advantage of multiple cores in your environment. Child processes can be spawned
by using our \[`child_process.fork()`]\[] API, and are designed to be easy to
communicate with. Built upon that same interface is the \[`cluster`]\[] module,
which allows you to share sockets between processes to enable load balancing
over your cores.

[bloqueando vs. não-bloqueando]: /learn/asynchronous-work/overview-of-blocking-vs-non-block
[`processo_filho.fork()`]: https://nodejs.org/api/child_process.html
[`agrupamento`]: https://nodejs.org/api/cluster.html
[máquina do evento]: https://github.com/eventmachine/eventmachine
[torcido]: https://twistedmatrix.com/trac/
