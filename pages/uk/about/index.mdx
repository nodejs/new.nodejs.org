---
title: Про Node.js®
layout: about
---

<div className="my-4 flex items-center justify-center">
  <img alt="Маскот Node.js" src="/static/images/node-mascot.svg" className="w-[100px]" />
</div>

***

# Про Node.js®

Як асинхронний подійно-орієнтований виконавчий середовище JavaScript, Node.js призначений для побудови масштабованих мережевих додатків. У наступному прикладі "hello world" багато з'єднань можуть бути оброблені одночасно. При кожному з'єднанні викликається зворотний виклик, але якщо немає роботи, яка потребує виконання, Node.js буде спати.

```js
const http = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Це відмінно від сьогоднішньої більш загальної моделі паралелізму, в якій використовуються потоки ОС. Мережева робота на основі потоків є відносно неефективною та дуже складною у використанні. Крім того, користувачі Node.js звільнені від страхів блокування процесу, оскільки тут немає блокувань. Майже жодна функція в Node.js не виконує вводу-виводу безпосередньо, тому процес ніколи не блокується, за винятком випадків, коли ввід-вивід виконується за синхронними методами стандартної бібліотеки Node.js. Тому що ніщо не блокується, розробка масштабованих систем у Node.js є дуже обґрунтованою.

Якщо якась з мов не знайома, на ній є повна стаття для
\[Блокування від блокування]\[].

***

Node.js подібний за дизайном до, і під впливом, систем, таких як \[Event Machine]\[] у Ruby та \[Twisted]\[] у Python. Node.js трохи далі використовує модель подій. Він представляє петлю подій як конструкцію виконавчого середовища, а не як бібліотеку. У інших системах завжди є блокуючий виклик для запуску петлі подій. Зазвичай поведінка визначається через зворотні виклики на початку сценарію, а в кінці сервер запускається через блокуючий виклик, наприклад `EventMachine::run()`. У Node.js немає такого виклику для запуску петлі подій. Node.js просто входить у петлю подій після виконання вхідного сценарію. Node.js виходить з петлі подій, коли не залишилося більше зворотних викликів для виконання. Ця поведінка схожа на браузерний JavaScript — петля подій прихована від користувача.

HTTP є громадянином першого класу в Node.js, розроблений з урахуванням потокової передачі та низької затримки. Це робить Node.js добре підходящим для основи веб-бібліотеки або фреймворку.

Те, що Node.js розроблений без потоків, не означає, що ви не можете скористатися перевагами кількох ядер у вашому середовищі. Дочірні процеси можуть бути створені за допомогою нашого \[`child_process.fork()`]\[] API та розроблені для легкої взаємодії. На основі цього ж інтерфейсу є модуль \[`cluster`]\[], який дозволяє вам обмінювати сокети між процесами для забезпечення балансування навантаження на ваші ядра.

[блокування проти неблокуючого]: /learn/asynchronous-work/overview-of-blocking-vs-non-blocking

[`child_process.fork()`]: https://nodejs.org/api/child_process.html

[`кластер`]: https://nodejs.org/api/cluster.html

[машина подій]: https://github.com/eventmachine/eventmachine

[згинається]: https://twistedmatrix.com/trac/
