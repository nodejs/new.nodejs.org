---
title: О Node.js®️
layout: about
---

<div className="центр элементов оправдывающий центр my-4 flex">
  <img alt="талисман Node.js" src="/static/images/node-mascot.svg" className="w-[100px]" />
</div>

***

# О Node.js®️

Являясь асинхронной программой выполнения JavaScript, Node.js разработан для сборки
масштабируемых сетевых приложений. В следующем примере "hello world" множество соединений
могут обрабатываться одновременно. При каждом соединении вызывается
вызов, но если работа не будет выполнена, Node.js будет спать.

```js
const http = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Это в отличие от более распространенной модели параллелизма сегодня, в которой используются потоки ОС. Сетевое взаимодействие на основе потоков относительно неэффективно и очень сложно использовать. Более того, пользователи Node.js освобождены от опасений блокировки процесса, поскольку здесь нет блокировок. Почти ни одна функция в Node.js не выполняет ввод-вывод напрямую, поэтому процесс никогда не блокируется, за исключением случаев, когда ввод-вывод выполняется с использованием синхронных методов стандартной библиотеки Node.js. Поскольку ничто не блокирует, разработка масштабируемых систем в Node.js вполне разумна.

Если некоторые из этих языков незнакомы, существует полная статья об
\[Блокировка против блокировки]\[].

***

Node.js разрабатывает такие системы, как
\[Event Machine]\[] и \[Twisted]\[]. Node.js дальше принимает модель события немного
. Он представляет цикл событий как конструкцию рабочего времени, а не как библиотеку. В других системах,
всегда блокирует вызов, чтобы запустить цикл событий.
Обычно поведение определяется через обратные вызовы в начале скрипта, и
в конце сервера запускается через блокирующий вызов типа `EventMachine::run()`.
В Node.js, нет такого запуска-циклического вызова event-cycle. Node.js просто входит в цикл событий после выполнения входного скрипта. Node.js
завершает цикл события, когда больше нет обратных вызовов. Это поведение
подобно браузеру JavaScript — цикл событий скрыт от пользователя.

HTTP в Node.js считается объектом первого класса, разработанным с учетом потоковой передачи данных и низкой задержки. Это делает Node.js отлично подходящим для основы веб-библиотеки или фреймворка.

Тот факт, что Node.js разработан без потоков, не означает, что вы не можете использовать несколько ядер в вашей среде. Дочерние процессы могут быть запущены с использованием нашего API `child_process.fork()`, и предназначены для удобной связи. На основе этого же интерфейса построен модуль `cluster`, который позволяет вам обмениваться сокетами между процессами для обеспечения балансировки нагрузки по ядрам.

[блокировка или неблокировка]: /learn/asynchronous-work/overviews-blocking-vs-non-blockking

[`child_process.fork()`]: https://nodejs.org/api/child_process.html

[«кластер»]: https://nodejs.org/api/cluster.html

[машина событий]: https://github.com/eventmachine/eventmachine

[закрученный]: https://twistedmatrix.com/trac/
