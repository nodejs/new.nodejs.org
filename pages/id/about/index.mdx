---
title: Tentang Node.js®
layout: about
---

<div className="my-4 flex items-center justify-center">
  <img
    alt="Maskot Node.js"
    src="/static/images/node-mascot.svg"
    className="w-[100px]"
  />
</div>

---

# Tentang Node.js®

Sebagai runtime JavaScript berbasis peristiwa asinkron, Node.js dirancang untuk membangun aplikasi jaringan yang dapat diskalakan. Pada contoh "hello world" berikut, banyak koneksi dapat ditangani secara bersamaan. Setiap koneksi, pemanggilan balik dipicu, tetapi jika tidak ada pekerjaan yang harus dilakukan, Node.js akan tidur.

```js
const http = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Hal ini berbeda dengan model konkurensi yang lebih umum saat ini, di mana benang OS digunakan. Jaringan berbasis benang relatif tidak efisien dan sangat sulit digunakan. Selain itu, pengguna Node.js bebas dari kekhawatiran mengunci proses, karena tidak ada kunci. Hampir tidak ada fungsi dalam Node.js yang melakukan I/O secara langsung, sehingga proses tidak pernah diblokir kecuali saat I/O dilakukan menggunakan metode sinkron dari pustaka standar Node.js. Karena tidak ada yang diblokir, sistem yang dapat diskalakan sangat masuk akal untuk dikembangkan di Node.js.

Jika beberapa bahasa ini tidak familiar, ada artikel lengkap tentang \[Blocking vs. Non-Blocking]\[].

---

Node.js mirip dalam desain dengan, dan dipengaruhi oleh, sistem seperti \[Event Machine]\[] milik Ruby dan \[Twisted]\[] milik Python. Node.js mengambil model peristiwa sedikit lebih jauh. Ini menyajikan loop peristiwa sebagai konstruk run-time daripada sebagai pustaka. Di sistem lain, selalu ada pemanggilan blokir untuk memulai loop peristiwa. Biasanya, perilaku didefinisikan melalui pemanggilan balik di awal skrip, dan di akhir server dimulai melalui pemanggilan blokir seperti `EventMachine::run()`. Di Node.js, tidak ada pemanggilan memulai loop peristiwa seperti itu. Node.js hanya memasuki loop peristiwa setelah menjalankan skrip masukan. Node.js keluar dari loop peristiwa ketika tidak ada lagi pemanggilan balik yang harus dilakukan. Perilaku ini mirip dengan JavaScript browser — loop peristiwa tersembunyi dari pengguna.

HTTP adalah warga negara kelas satu di Node.js, dirancang dengan streaming dan latensi rendah
pikiran. Hal ini membuat Node.js sangat cocok untuk dasar dari sebuah web
perpustakaan atau kerangka kerja.

Node.js yang dirancang tanpa benang tidak berarti Anda tidak dapat memanfaatkan
keuntungan dari beberapa inti di lingkungan Anda. Proses anak dapat dihasilkan
dengan menggunakan API \[`child_process.fork()`]\[] kami, dan dirancang untuk mudah
berkomunikasi. Dibangun di atas antarmuka yang sama adalah modul \[`cluster`]\[],
yang memungkinkan Anda untuk berbagi soket antara proses untuk memungkinkan penyeimbangan beban
atas inti Anda.

[blocking vs. non-blocking]: /learn/asynchronous-work/overview-of-blocking-vs-non-blocking
[`child_process.fork()`]: https://nodejs.org/api/child_process.html
[`cluster`]: https://nodejs.org/api/cluster.html
[mesin acara]: https://github.com/eventmachine/eventmachine
[berbelit-belit]: https://twistedmatrix.com/trac/
