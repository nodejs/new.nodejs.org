---
layout: about.hbs
title: О проекте
trademark: Торговая марка
---

# Про Node.js&reg;

Как асинхронное событийное JavaScript-окружение, Node спроектирован для построения
масштабируемых сетевых приложений. Ниже приведен пример "hello world", который
может одновременно обрабатывать много соединений. Для каждого соединения вызывается
функция обратного вызова, однако когда соединений нет Node засыпает.

```javascript
const http = require("http");

const hostname = "127.0.0.1";
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader("Content-Type", "text/plain");
  res.end("Hello World\n");
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Это контрастирует с более общей моделью, в которой используются параллельные OS
потоки. Такой подход является относительно неэффективным и очень трудным в использовании.
Более того, пользователи Node могут не беспокоиться о блокировании процессов,
поскольку нет никаких блокировок. Почти ни одна из функций в Node
не работает напрямую с I/O, поэтому поток не блокируется никогда. Поскольку ничего
не блокируется ― на Node легко разрабатывать масштабируемые системы.

Если что-то в этом подходе непонятно для вас, предлагаем посмотреть
полную статью [Blocking vs Non-Blocking][].

---

Node создан под влиянием таких систем как [Event Machine][] в Ruby или
[Twisted][] в Python. Node использует событийную модель значительно шире,
он принимает [event loop][] за основу окружения, вместо того,
чтобы использовать его в качестве библиотеки. В других системах всегда происходит
блокировки вызова, чтобы запустить цикл событий.

Обычно поведение определяется через функции обратного вызова в начале
скрипта и в конце запускает сервер через блокирующий вызов,
вроде `EventMachine :: run ()`. В Node нет ничего похожего на вызов начала
цикла событий. Node просто входит в событийный цикл после запуска скрипта на
выполнения. Node выходит из событийного цикла тогда, когда не остается
зарегистрированных функций обратного вызова. Такое поведение похоже на поведение
браузерного JavaScript: событийный цикл скрыт от пользователя.

HTTP является объектом первого рода в Node, разработанным с поточностью и малой задержкой. Это делает Node хорошей основой для веб-библиотеки или фреймворка.

То что Node спроектирован без многопоточности, не означает, что вы не можете
использовать возможности нескольких ядер в вашей среде. Вы можете
создавать дочерние процессы, которыми легко управлять с помощью API
[`Child_process.fork()`][]. Модуль [`cluster`][] построен на этом
интерфейсе и позволяет делиться сокетами между процессами и
распределять нагрузку между ядрами.

[blocking vs non-blocking]: https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/
[`child_process.fork()`]: https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options
[`cluster`]: https://nodejs.org/api/cluster.html
[event loop]: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
[event machine]: https://github.com/eventmachine/eventmachine
[twisted]: http://twistedmatrix.com/
