---
layout: about.hbs
title: პროექტის შესახებ
trademark: სავაჭრო ნიშანი
---

# Node.js®-ის შესახებ

როგორც ასინქრონული, მოვლენებზე დაფუძნებული JavaScript-ის გამშვები გარემო, Node.js შექმნილია
მასშტაბირებადი (გაფართოებადი) ქსელური აპლიკაციების შესაქმნელად. ქვემოთ მოცემულ ("hello world") მაგალითში
შესაძლებელია ერთდროულად მრავალი კავშირის დამუშავება. თითოეული კავშირისთვის მოხდება (callback) ფუნქციის
გამოძახება, მაგრამ თუ გასაკეთებელი არაფერია, Node.js დარჩება უმოქმედოდ (დაიძინებს).

```javascript
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

ეს მიდგომა განსხვავდება დღესდღეობით უფრო გავრცელებული პარალელიზმის მოდელისგან, რომელიც OS ნაკადებს (threads) იყენებს.
ნაკადზე დაფუძნებული მიდგომა შედარებით არაეფექტურია და ძალიან
რთულია გამოსაყენებლად. გარდა ამისა, Node.js-ის მომხმარებლებს არ უწევთ იდარდონ
პროცესების ბლოკირებაზე, რადგან აქ არ არსებობს ბლოკირება.
Node.js-ის თითქმის არც ერთი ფუნქცია არ ახორციელებს უშუალოდ შეტანა/გამოტანას, ამიტომ პროცესი არასოდეს იბლოკება გარდა იმ შემთხვევისა, როცა შეტანა/გამოტანა ხორციელდება
Node.js-ის სტანდარტული ბიბლიოთეკის სინქრონული მეთოდების გამოყენებით. ყოველივე ამის გამო, მასშტაბირებადი სისტემების
Node.js-ის გამოყენებით შექმნა ძალიან გონივრულია.

თუ გამოყენებული ტერმინებიდან თქვენთვის რომელიმე გაუგებარია, იხილეთ სრული სტატია:
[Blocking vs. Non-Blocking][].

---

Node.js დიზაინით მსგავსია და იმყოფება გავლენის ქვეშ ისეთი სისტემებისა, როგორებიცაა:
[Event Machine][] Ruby-ში და [Twisted][] Python-ში. თუმცა, Node.js-ში მოვლენათა მოდელი ბევრად უფრო
ფართოდ გამოიყენება. იგი წარმოგვიდგენს [მოვლენათა ციკლს][], როგორც გამშვები გარემოს კონსტრუქციას, ნაცვლად იმისა, რომ წარმოგვიდგინოს ბიბლიოთეკის სახით. სხვა სისტემებში
ყოველთვის გვაქვს დამბლოკველი გამოძახება, რათა მოხდეს მოვლენათა ციკლის დაწყება.
როგორც წესი, ქცევა განისაზღვრება ფუნქციების მეშვეობით სკრიპტის დასაწყისში და
ბოლოში — დამბლოკველი გამოძახების მეშვეობით, როგორიცაა `EventMachine::run()` — სერვერი ეშვება.
Node.js-ში არ გვაქვს მსგავსი გამოძახება მოვლენათა ციკლის დასაწყებად: იგი (შემავალი) სკრიპტის გაშვების შემდეგ ავტომატურად შედის მოვლენათა ციკლში.
როდესაც განსახორციელებელი ფუნქციები (callbacks) აღარ დარჩება, Node.js გამოდის მოვლენათა ციკლიდან. ეს ქცევა
ჰგავს JavaScript-ის ქცევას ბრაუზერში: მოვლენათა ციკლი დამალულია მომხმარებლისაგან.

HTTP-ს განსაკუთრებული ადგილი უკავია Node.js-ში, რომელიც შექმნილია სტრიმინგისა და დაბალი
შეყოვნების გათვალისწინებით. ეს Node.js-ს აქცევს იდეალურ საფუძვლად
ვებ-ბიბლიოთეკის ან framework-ის დასაშენებლად.

ის ფაქტი, რომ Node.js შექმნილია ნაკადების (threads) გარეშე არ ნიშნავს იმას, რომ არ შეგიძლიათ
თქვენს გარემოში ისარგებლოთ მრავალი ბირთვით. შვილობილი პროცესების წარმოქმნა შეგიძლიათ
[`child_process.fork()`][] API-ის გამოყენებით.
ამავე ინტერფეისის საფუძველზეა აგებული [`cluster`][] მოდული,
რომელიც საშუალებას გაძლევთ, დაყოთ სოკეტები პროცესებს შორის,
რათა დატვირთვა გადანაწილდეს ბირთვებზე.

[Blocking vs. Non-Blocking]: /en/docs/guides/blocking-vs-non-blocking/
[`child_process.fork()`]: https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options
[`cluster`]: https://nodejs.org/api/cluster.html
[მოვლენათა ციკლს]: /en/docs/guides/event-loop-timers-and-nexttick/
[Event Machine]: https://github.com/eventmachine/eventmachine
[Twisted]: https://twistedmatrix.com/trac/
